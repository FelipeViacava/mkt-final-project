---
title: "Marketing Analytics"
subtitle: "Customer Churn"
footer: "Insper -- Marketing Analytics, set/23"
format:
    revealjs:
        theme: solarized
        scrollable: true
css: custom.css
execute:
    python: env/bin/python
---
```{python}
#| echo: false
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from scipy.stats import chi2_contingency

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.compose import ColumnTransformer

pd.set_option('display.precision', 2)
```

```{python}
#| echo: false
df = pd.read_csv("data/telecom_churn.csv")
train, test = train_test_split(
    df,
    test_size=0.2,
    random_state=42
)
```

# Introdução
1. Conjunto de dados
2. Objetivo
3. Metodologia

## Conjunto de dados
- [Customer Churn](https://www.kaggle.com/datasets/barun2104/telecom-churn?resource=download)
- Telecomunicações
- Análise apenas no conjunto de treino

## Objetivo
- Entender o que leva um cliente a cancelar o serviço
- Segmentar o público para ações de marketing
- Criar um modelo de classificação de churn

## Metodologia
- Interpretação: Regressão Logística
- Segmentação: Cluster Hierárquico
- Classificação: Gradient Boosting

# Conjunto de dados

## Variáveis

***Churn***: Indicadora de churn

***ContractRenewal***: Indicadora de renovação de contrato do cliente

***DataPlan***: Indicadora de plano de dados

***AccountWeeks***: Número de semanas de conta ativa

***CustServCalls***: Número de ligações para o serviço de atendimento

***DayCalls***: Número médio de ligações diurnas

***DataUsage***: Volume mensal de dados (GB)

***DayMins***: Tempo médio de ligações diurnas (min)

***RoamMins***: Tempo médio de ligações em roaming (min)

***MonthlyCharge***: Fatura mensal média

***OverageFee***: Maior taxa de uso excedente nos últimos 12 meses
 
## Overview dos dados

Como temos apenas variáveis numéricas, usamos o método `describe` para obter uma visão geral dos dados.
```{python}
#| echo: false
train.describe()
```

## Variáveis binárias

Ocorrência separada por churn

```{python}
#| echo: false
binary = ["ContractRenewal", "DataPlan"]
train \
    .groupby("Churn")[binary] \
    .mean() \
    .map(lambda x: f"{x:.1%}")
```

## Variáveis discretas

```{python}
discrete = [
    "AccountWeeks",
    "DayCalls",
    "CustServCalls"
]
train \
    .groupby("Churn")[discrete] \
    .agg(["mean", "std"])
```

```{python}
#| echo: false
fig, ax = plt.subplots(1, 3, figsize=(12, 4))
fig.subplots_adjust(wspace=0.35)

for i, col in enumerate(discrete):
    train[train["Churn"]==0][col] \
        .plot(
            kind="hist",
            density=True,
            ax=ax[i],
            color="blue",
            legend=(col=="CustServCalls"),
            alpha=.5,
            bins=(5 if col=="CustServCalls" else 15)
        )
    train[train["Churn"]==1][col] \
        .plot(
            kind="hist",
            density=True,
            ax=ax[i],
            color="red",
            legend=(col=="CustServCalls"),
            alpha=.5,
            bins=(5 if col=="CustServCalls" else 15)
        )
    ax[i].set_title(col)
    ax[i].set_xlabel("")
    ax[i].set_ylabel("")
    ax[i].legend(["Manteve", "Deixou"] if col=="CustServCalls" else "")
```

## Variáveis contínuas

```{python}
#| echo: false

continuous = [
    "DataUsage",
    "DayMins",
    "RoamMins",
    "MonthlyCharge",
    "OverageFee"
]

train \
    .groupby("Churn")[continuous] \
    .agg(["mean", "std"])
```

```{python}
#| echo: false

fig, ax = plt.subplots(1, 5, figsize=(12, 4))
fig.subplots_adjust(wspace=.4)

for i, col in enumerate(continuous):
    train[train["Churn"]==0][col] \
        .plot(
            kind="hist",
            density=True,
            ax=ax[i],
            color="blue",
            legend=(col=="DataUsage"),
            alpha=.5,
            bins=(15 if col=="DataUsage" else 15)
        )
    train[train["Churn"]==1][col] \
        .plot(
            kind="hist",
            density=True,
            ax=ax[i],
            color="red",
            legend=(col=="DataUsage"),
            alpha=.5,
            bins=(15 if col=="DataUsage" else 15)
        )
    ax[i].set_title(col)
    ax[i].set_xlabel("")
    ax[i].set_ylabel("")
    ax[i].legend(["Manteve", "Deixou"] if col=="DataUsage" else "")
```

# O que causa o churn?

## Regressão Logística

## Análise dos resultados

# Segmentação dos clientes

## Cluster Hierárquico

## Análise dos clusters

# Modelo de classificação

## Gradient Boosting

## Análise dos resultados

# Considerações finais